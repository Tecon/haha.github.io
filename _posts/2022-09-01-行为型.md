---
title:  "行为型模式"
author:
  name: liuhe
  link: https://tecon.github.io
date:  2022-09-01 09:49:59 +0800
categories: [work, 利其器]
tags: [design pattern]
toc: false
---


#### 责任链模式

&ensp;&ensp;使多个对象都有机会处理请求，从而解耦请求的发送者和接收者。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。责任链适用于有多个业务侧处理，且需要动态的决定使用哪个业务处理的场景。责任链的变种-管道模式在实际生产中使用较为广泛，区别在于，严格的责任链模式，链上只有一个业务来处理，而管道模式是将对象流过管道中的所有阀门，每个都处理一遍。**生产中适用于网关中间件的数据预处理、大数据中的数据清洗、广告业务中的打点计费处理、分销业务中的多级分销计算等**责任链模式中由于需要在链上传递信息，所以一般会有上下文作为参数，保存输入、输出、状态等信息

传统的责任链模式如下：

<img src="/2022/09/upgit_20220901_1661996687.png" alt="image-20220816122227836" style="zoom:50%;" />

这种方式每个handler自行维护next()节点，整个链路只有一个handler处理请求。这种方式无法灵活的添加、移除节点，同时各个节点的顺序散落在各个handler中，不便于后期维护，可以使用单独的`List<Handler>`来维护链，然后client依次调用各个handler，解决以上两个问题。

对于需要每个handler都对数据进行处理的场景，可以考虑责任链模式的变种-管道模式，如下图所示

todo（UML & demo）

#### 命令模式

​		指将请求封装为一个对象，以便参数化表示客户请求、对请求排队、记录请求，并且支持可撤销操作。命令模式可以和观察者、状态等模式结合实现功能。**实际生产中比较常见的是Redis的cli和server交互时使用命令模式；还有Runnable也是命令模式的实践（通过Runnable对象封装了实际的run()逻辑，传递给Thread完成实际的线程运行过程）**该模式的核心在于将请求封装为对象并交由第三方Invoker或Caller执行，实际执行逻辑在command对象和要处理的question中，通常核心逻辑在question中，command对象仅做“开场准备”和“打扫战场”，极端场景command什么都不做，仅仅是调用传递。当然，对于静态的question，封装太多的业务逻辑也不太合理，这种情况可以使用中介者模式添加中介，封装为question的处理类，收敛核心处理逻辑的同时避免静态question对象的职责无限外延

<img src="/2022/09/upgit_20220901_1661996691.png" alt="image-20220901011854664" style="zoom:50%;" />

#### 解释器模式

​		解释器模式通常用来解决特定的、出现频率足够高的问题，通过将问题的各个实例描述为一个表达式，给出表达式的通用解释（可能是查找匹配规则、可能是运算规则），解释该表达式后得出结论（问题的解）。解释器的核心在于使用类来表示每一条规则（解释），非常方便修改、扩展规则。**生产中常见的是正则匹配，如java.util.Pattern，自定义算术、逻辑运算规则，还有就是在规则中心非常常见，用于解释执行各种自定义规则文本**

<img src="/2022/09/upgit_20220901_1661996695.png" alt="image-20220901021257802" style="zoom:50%;" />

#### 迭代器模式

​		迭代器常见用于访问各种容器，在不暴露容器内部实现的基础上完成容器内元素的遍历。迭代器分为内部迭代器和外部迭代器，外部迭代器由客户主动获取下一元素，内部迭代器仅需客户提交待执行动作即可。迭代器的实现通常与容器本身的数据结构相关。

#### 中介者模式

​		中介者模式用一个中介对象来封装一系列的对象交互。通常情况下，当系统当前的抽象层次无法很好的应对业务的复杂性导致部分逻辑或者部分职责混杂时，中介者模式就可以登场了，此时我们使用中介者模式来增加抽象层次，将混杂的部分逻辑或者混杂的职责进行划分，将部分逻辑与职责划分到新的中介者层次中，由中介者来完成相应对象的交互。在上面命令模式的解释中，就有这种场景的存在

#### 备忘录模式

​		备忘录模式顾名思义，为对象建立备忘记录，以方便后续恢复，当然，是在不破坏对象的封装性（不暴露对象的实现细节）的前提下。实际的工作中，很少有这种需要在不暴露对象实现细节的前提下给对象建立内存备忘记录的场景，一般需要存储时都会使用存储中间件，至于本地缓存的情况，虽然与备忘录模式手段相似，但目的相差甚远。因此，笔者实际工作中遇到的相应场景较少，理解不足，暂时不展开，待后续补充

#### 观察者模式

​		观察者模式用于实现发布-订阅功能，当对象状态变更时，订阅了对象变更的用户都将得到通知，且通知的对象和被观察的对象没有强耦合。**实际生产中，这种发布-订阅的应用非常常见，小到多渠道通知（如站内消息、短信、消息推送）、大到商品变更订阅，都是观察者模式的运用，只是在实践中，如何运用也差别巨大。比如类似多渠道通知这种，使用观察者模式有些重，更大的挑战在通知的多样性，而不是通知渠道的多寡，因此这种场景使用与否就看开发者个人了；而类似商品变更订阅、订单状态变更订阅，则要健壮的多的多，通常不会使用这种内存式的观察者模式，而是在引入中间件的基础上完成订阅，比如自行订阅商品变更的binlog消息完成下游逻辑、订阅订单中心包装的订单状态变更消息完成下游逻辑，这样做，一方面比之内存式的订阅要稳健的多，不会因为单机内存快速增长引起稳定性问题；同时也避免了大量业务杂糅到单机引起的内聚问题；而且在扩展性上也大大增强，方便快速的扩展软硬件以应对业务规模的快速增长**

#### 状态模式

​		允许对象在内部状态变更时改变它的行为。对象看起来似乎修改了类（实际上还是原有的类，只是修改了持有的对象，以达到改变行为的目的）。**实际生产中，多用于需要根据状态执行不同行为的系统，比如售后系统就可以很好的运用状态模式结合预先制定好的状态机完成售后订单的流转**

<img src="/2022/09/upgit_20220901_1661996701.png" alt="image-20220901042504702" style="zoom:50%;" />



#### 策略模式

​		策略模式用于在不同场景需要不同计算、存储、映射逻辑的情况下。通常预定义好不同的策略，在使用时根据当前情况选择适当的策略，完成相应的逻辑。**实际生产中，该模式通常和工厂模式配合使用，常见于选择负载均衡策略、序列化方法、算法实现；对于业务流程大致相似，但又有细微差别的，通常也会选择使用策略模式实现，或者前期代码堆叠以便于快速响应，在业务膨胀之后改用策略模式以便于方便维护。**

<img src="/2022/09/upgit_20220901_1661996711.png" alt="image-20220901044533594" style="zoom:50%;" />

#### 模板方法模式

​		模板方法模式通过定义一个操作中的主流程骨架，将一些具体步骤延迟到子类中，从而达到不改变主流程的前提下重定义流程内某些步骤的目的。	**这种模式在实际工作中大量运用，有的是出于减少公共冗余代码的目的；有的是方便业务下游自定义具体算法（比如上面策略模式，提供不同的负载均衡策略，同时支持业务方自定义策略）；有的是定义好主流程，后续只需修改子类即可完成业务需求（比如上方的管道模式，定义好管道的流程，后续仅需修改、增添不同的阀门即可）；有的是为了避免中间件切换侵入业务逻辑（将业务相关逻辑放在模板方法中）**

相应的案例看上面的管道模式吧，此处不再赘述

#### 访问者模式

​		访问者模式允许在不改变对象已有的各属性元素的类的前提下添加作用于这些元素的新操作。不使用访问者模式时，需要将静态对象分别传递给不同的类做处理，使用访问者模式后，关注重点变成静态对象本身，将静态对象accept各个访问者。这是两种编程的思想，一种将资源给到各个运算逻辑执行运算，一种将运算逻辑在资源上“重放”一遍完成运算。visitor模式有效的避免了将单个静态对象从头传到尾的情况，定义不同的visitor，使静态对象接受或应用不同的访问者完成业务逻辑。笔者实际工作中遇到的相应场景较少，理解不足，暂时不展开，待后续补充

<img src="/2022/09/upgit_20220901_1661996719.png" alt="image-20220901052523594" style="zoom:50%;" />
