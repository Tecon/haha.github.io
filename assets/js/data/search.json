[ { "title": "LEGION Y7000P 2019安装黑苹果", "url": "/posts/LEGION-Y7000P-2019%E5%AE%89%E8%A3%85%E9%BB%91%E8%8B%B9%E6%9E%9C/", "categories": "life, 好玩", "tags": "黑苹果, 折腾", "date": "2023-05-27 22:06:49 +0800", "snippet": "硬件准备：型号：Legion Y7000P 2019CPU：INTEL i5-9300H@2.4G内存：2*8G硬盘：三星PM981A（1T）无线：Intel AC9560有线：RTL8111H购买西数SN770替换原有的PM981A，其他保持不变，使用intel AC9560无线网卡，仅满足日常使用，其他诸如随航、隔空投递暂时忽略，后续根据使用体验考虑是否更换无线网卡软件准备镜像：使用macOS Monterey 12.6.5（以后也准备在这个系统养老了）黑苹果专用引导系统镜像EFI： 配置如果和上面笔者的配置相同可以直接使用最下面经过修改和验证后的EFIGitHub - gclm/Hackintosh-LEGION-Y7000P-I7-9750H: 联想拯救者Y7000P I7-9750H 准完美级 EFI安装过程参考：Course/README.md · 孤城落寞/Hackintosh-LEGION-Y7000P-I7-9750H - Gitee.com安装后FIX HiDPI：参考安装过程最后提示，但是有点问题，就是无法使用1920*1080P的，调成最大的还是模糊 查看这个可以继续改进，还有就是开机或者关机时会花屏，影响观感实际解决方法类似这篇文章，不过在这里查到更近似的smbios，并使用OCC修改，发现EFI中的CPU为Cannon Lake架构，调整描述为Caffee Lake，修改后重启，HiDPI基本正常，目前使用1440*810，基本不太模糊了，虽然还是比windows差点 耳机&amp;amp;外放：音质几乎无法用，怀疑是哪里有问题，Hackintool上面音频部分显示可能需要仿冒id 升级oc到0.9.2并相应升级kext后，外放正常；有线耳机仍然无法使用。参考这里找到新的layoutid，使用occ更换为11后开机黑屏，降低亮度好了，然后对比原来plist文件，发现是EgAAA改成了CwAAA，另一处修改移除，使用仅修改了CwAAA的plist，问题解决，有线耳机、外放、蓝牙耳机均正常使用 键盘问题：部分软件不认左边的Ctrl（调整win徽标键和alt键位置时意外的好了），win徽标键和alt键需要调整下位置，确保和mbp体验一致， 又发现新的问题了，每次重启，可能ctrl、fn、alt三个按键不规律异常，可能都是ctrl，也可能ctrl、fn无作用，alt正常，也可能三个都无作用，待处理 键盘问题是因为原本的按键和迁移mac数据后，在mac上的/Library/LaunchDaemons/com.local.KeyRemapping.plist交换ctrl和fn冲突，导致ctrl和fn出现各种不可预知的异常，再加上又在另一个位置/Users/haha/Library/LaunchDaemons/添加了交换command和option的plist，导致冲突加剧，移除mac迁移过来的ctrl和fn交换，并将command和option位置交换的plist放在/Library/LaunchDaemons/下，问题解决 启动问题：输出代码想办法去掉 设置下OC自动选择某个选项，无需确认可以直接不显示选择哪个系统show-picker设置为false即可，这样太粗暴了，可以将show-picker下面的timeout设置为1；另外输出boot-args选项去除-v 蓝牙：基本处于不可用状态，无法发现其他蓝牙设备 修改plist中的无线网卡型号从原来的ax200到ac9560，将oc从0.8.2升级到0.9.2，并相应升级kext后，蓝牙基本正常（无法连接apple设备，手上的1000xm3无法连接，其他没问题，音质也正常）,wh-1000xm3在进入配对模式后可以识别，没问题了 未解决问题： 蓝牙无法连接wh1000xm3（其他蓝牙耳机正常），蓝牙无法连接apple系产品（apple自己的产品之间蓝牙连接也有问题） 关机时会花屏一下，影响不大 AirDrop无法使用，看后续是否更换免驱网卡吧 最终的EFI至此，硬件体验基本已经和windows的一致了，分享下最终的EFI文件拯救者Y7000P 2019黑苹果EFI文件 访问码：3x4d" }, { "title": "科目三", "url": "/posts/%E7%A7%91%E7%9B%AE%E4%B8%89/", "categories": "life, 驾考", "tags": "driving", "date": "2023-01-29 20:37:04 +0800", "snippet": " 本文记录科目三考试时的一些注意事项，不同驾校略有区别，仅供参考开始前准备身份证交给安全员，核对身份，调整座椅，检查左右后视镜，内视镜检查车辆各项状态： 灯光总开关在0位 拨动灯光操纵杆确认操纵杆在中间位置 档位在空挡位 手刹为拉起状态 上车准备开始考试，观察左后视镜，车门开一条缝，确认安全后下车，沿车身逆时针一周检查，到达车身后方保险杠位置、右前轮胎、前方车牌、左前轮胎时，按下感应器，确认安全上车，关门，系上安全带核对身份后开机准备考试，开始夜间灯光模拟考试夜间行驶模拟模拟灯光打开前照灯（近光灯）夜间通过坡路（远近交替两下）夜间在路边临时停车（打开示廓灯、危险警报灯，关闭近光灯【后面的所有项目都需要先关闭示廓灯、警报灯】）夜间与机动车会车（远近交替两下）夜间超车（远近交替两下）夜间通过急弯、坡路、拱桥、人行横道（远近交替两下）完成后关闭所有灯光（灯光总开关归零位）起步（从挂1档起算10s内）开启左转向灯踩离合、刹车观察左右后视镜、内视镜，松开手刹确认安全后，挂一档，起步（松刹车、轻松离合）车身稳定后，踩油门把车速提升至10+，换二档（换挡前不得超过50米）关闭左转向灯路口左转开启左转向灯到达转向指示箭头前，轻点刹车，可以刹车2次确保机器识别到该动作观察左前，左侧，右后（右后视镜），确认安全后缓慢通过变更车道语音播报后，开启左/右转向灯，保持3秒以上，观察左/右后视镜，确认安全后向左变更车道，完成后关闭转向灯，注意在指定范围内完成变更车道，超过范围未完成变更车道考试不及格直线行驶坐姿正确，目视前方100m左右远处，保持直线行驶路口掉头语音播报后，开启左转向灯，可以踩刹车减速，保持车辆在车道正中间，或靠右行驶，左打满方向盘，完成掉头加减档猛踩油门加速30km/h~ 松油门，踩离合，挂3挡，松离合，猛踩油门40km/h~ 松油门，踩离合，挂4档，松离合松开油门降速，行驶5秒以上30km/h~ 踩离合，退2档，慢慢松离合，完成加减档路口右转开启右转向灯到达转向指示箭头前，轻点刹车，控制速度观察左前，左侧，右后（右后视镜），确认安全后缓慢通过会车语音播报后踩刹车减速超车语音播报后，开启左转向灯，保持3秒以上，观察左后视镜，确认安全后向左变道，车正且方向盘正之后开启右转向灯，保持3秒以上，观察右后视镜，确认安全后驾驶回原车道，并关闭右转向灯公交车站前方公交车站没有语音播报，需要左右观察，踩刹车减速通过人行横道通过人行横道没有语音播报，需要左右观察，踩刹车减速通过学校区域前方学校区域没有语音播报，需要左右观察保持车速在30以下缓慢通过前方直行踩刹车减速，观察左侧，左前，右后方，确认安全后通过路口靠边停车语音播报后，开启右转向灯，保持3秒以上离合、刹车、油门都不踩，2档怠速行驶调整车身与道路边缘线在30公分以内（方向盘向道路边缘打15°并立刻回正，多次操作即可）猛踩离合，猛踩刹车，停车（关闭转向灯，摘空挡），拉手刹熄火，解安全带，松离合，松刹车，下车前观察左后方确认安全后下车" }, { "title": "科目二", "url": "/posts/%E7%A7%91%E7%9B%AE%E4%BA%8C/", "categories": "life, 驾考", "tags": "driving", "date": "2023-01-29 20:27:04 +0800", "snippet": " 本文记录科目二考试时的一些注意事项，不同驾校略有区别，仅供参考倒车入库、出库右库肩膀与黄色控制线对齐停车，准备倒车倒车时观察左后视镜，下沿压黄色控制线时向右打死方向盘打死后观察右后视镜，车身压入库的虚线后回一圈方向盘观察右后视镜与库角斜线有1指宽度时重新向右打死正方向盘观察左右后视镜，调整方向盘，保持车身与车库黄线平行（哪边越来越窄往那边打方向盘）左后视镜下边沿与黄线贴合，停车出库时观察左后方车轮，出车库黄色虚线时向右打死方向盘，车身回正后打正方向盘左库肩膀与黄色控制线对齐停车，准备倒车倒车时观察左后视镜下沿压黄色控制线时向左打死方向盘观察左后视镜，后车轮刚好在黄色虚线边缘为宜（与车库库角保持2指宽度），直至车身与车库两侧黄线平行，回正方向盘左后视镜下边沿与黄线贴合，停车出库时观察左后方车轮，出车库黄色虚线时向左打死方向盘，车身回正后打正方向盘侧方停车停车保持车身右侧与黄线大约30公分，库角大约在右后视镜中心位置靠上一些停车准备倒车（或右雨刷突出位置与黄线贴合）直线倒车，当库角从右后视镜中央到下边沿并消失时向右将方向盘打满观察左后视镜，出现后库角出现时回正方向观察左后视镜，后轮与黄线一拳距离时，向左打满方向盘观察左右后视镜，车身与黄线平行时，踩死离合、刹车，停车，挂空挡出车开启左转向灯，保持方向盘不动（停车时是左打满方向盘状态），挂1档出库车头左前方边缘与黄线重合时，回正方向，大约1-2秒后向右打一圈，（观察右后视镜，右后轮与入库时库角大约20公分）调整车身与黄线平行，将方向盘回正直角弯开启左转向灯，开门的门把手尾部三角与黄线基本平齐时，向左方向盘打满，并关闭左转向灯，观察后轮与黄线直角，大约在20公分为宜，差距太近，可以适当回一些方向S弯方向盘0点位置对准前方道路中间机盖前边缘左大灯位置对上黄线时，左打一圈，保持该位置沿黄线行驶，期间观察左后视镜，后轮与白线保持20公分为宜进入S弯道后半段，机盖左侧边缘线对上左侧黄线时回正方向盘机盖前边缘中间点对上黄线后过1-2秒后，向右打一圈方向盘，保持机盖右大灯沿黄线行驶，观察右后视镜，后轮与白线保持20公分为宜车辆出弯道后逐步回正方向盘半坡起步与停车车身与右侧黄线控制在30cm行驶（可观察右侧雨刷和车头1/3处重合，贴右侧黄线行驶）左侧后视镜下边沿驶过黄色虚线，位于黄色实线上边沿时，同时踩死离合、刹车，拉手刹挂1档，松手刹，轻松离合，车身抖动后，左脚定住该位置1-2秒钟，然后轻松刹车，起步并向左稍带方向盘" }, { "title": "MySQL自问自答", "url": "/posts/9.MySQL%E8%87%AA%E9%97%AE%E8%87%AA%E7%AD%94/", "categories": "work, 利其器", "tags": "MySQL, 学习纪要", "date": "2022-09-17 06:46:49 +0800", "snippet": " 文章中未说明版本时以MySQL8.0为准1、mysql的结构是怎么样的？mysql是插件式的数据库管理系统，整体分为server层和引擎层，server层用于管理连接和用户权限、执行sql语句的分析与优化；引擎层用于实际数据的管理，可以实现插件式的装载与移除，故而可以选用不同的存储引擎。2、何为存储引擎，为何要有存储引擎？不同的mysql存储引擎有哪些优劣、适用场景作为数据库管理系统，核心功能是数据的管理，围绕数据的管理需要有连接管理、权限管理、sql语句分析与执行等相关功能，核心功能单独抽出来作为存储引擎，实现插件式的load与unload，一方面大大增强了整个dbms的可扩展性，针对不同场景的数据管理可以选用特定的存储引擎，大大提升数据管理的效率。另一方面，通过引擎层包装数据管理细节，应用开发者仅需关心一致性的server层api（sql语法）即可，可以快速的进行代码开发与移植。MYSQL存储引擎一览 存储引擎 特性 缺点 注意事项 适用场景 InnoDB 支持行锁、事务、一致性读、外键、自适应hash索引、MVCC；通过聚簇索引实现索引组织表 详见     mysql默认存储引擎，适用于绝大多数场景，如电商、社区、ERP等 MyISAM 支持外键、B-tree索引，表级锁；详见 不支持hash索引；不支持事务 8.0不再支持分区表   Memory 数据存储在内存中；表级锁；支持hash索引、B-tree索引 关机数据丢失   适用于存储瞬时数据或缓存，如session信息 CSV 数据以csv格式存在磁盘，metadata以同名的csm文件存储。以sql语句管理csv文本文件 数据容易人为损坏   需要和其他文本处理工具协同使用的场景，如Excel表格处理 Archive 适合归档存储数据 不支持索引、分区表、delete、update   主要用于存储大量的无索引归档数据 BlackHole 不存储数据；binlog为statement时存储binlog     做binlog过滤或查找与存储引擎无关的性能瓶颈 Merge 是MyISAM引擎相同表的merge，和分区表相对应       Federated 允许访问远程MySQL，从federated存储引擎查询数据会自动从远程MySQL拉数据 本身不存储任何数据     Example   不支持索引，不支持分区表   仅仅在源码中用于展示如何写一个新引擎 其他第三方引擎         3.1、mysql是如何组织数据的在mysql中数据的组织由存储引擎实现，这里仅介绍使用最广泛的存储引擎-InnoDB的数据组织形式innodb中数据存储在磁盘文件中，同时会利用内存作为缓存加速数据的读写，架构如下：Innodb中的数据包括实际数据以及维护实际数据所需的索引数据，通过聚簇索引这种数据组织形式维护数据。数据存储的逻辑结构：逻辑结构分级组织，依次为 表空间(tablespace) –&amp;gt; 段(segment) –&amp;gt; 区(extent) –&amp;gt; 页(page)，页内为物理存储结构：一行一行的数据。表空间表空间是Innodb逻辑存储的最高层，所有需要持久化的数据都会存储在表空间中。根据不同的用途，表空间分为系统表空间、通用表空间、独立表空间、Undo表空间、临时表空间。 系统表空间（System TableSpaces）​ innodb会默认创建名为ibdata1的文件，这就是系统表空间的物理存储，系统表空间用于存储buffer pool，未启用独立表空间时表的索引和数据，双写buffer pool（8.0.20+后移出系统表空间，独立存储）等这些公共的共享的数据 通用表空间（General Tablespaces）​ 通用表空间需要使用CREATE TABLESPACE语法创建，它也是一个共享表空间，只用于存储用户定义表的索引和数据，而不会存储其他诸如buffer pool这类共享数据 独立表空间（file-per-table Tablespaces）​ innodb默认开启innodb_file_per_table（5.6.6+），每个innodb表都会在data的对应scheme目录下单独创建表名.ibd文件存储。使用独立表空间在存储占用（可释放）、行格式支持（Dynamic和Compressed）、外挂存储、数据恢复、数据备份、表空间占用监控等方面相比使用共享的系统表空间或通用表空间具有很大的优势，当然，也需要更多的文件描述符、更多的打开文件、更多潜在的存储碎片、更多的文件句柄等系统资源，不过整体来讲，仍然是使用独立表空间更具优势，因此，除非特殊场景，尽量使用独立表空间存储表 Undo表空间（Undo Tablespaces）​ Undo表空间就是用来存储undo-log的，用于事物回滚操作。MySQL实例初始化时系统会在innodb_undo_directory 目录下创建2个默认的Undo表空间文件undo_001和undo_002用于后续存储undo log 临时表空间（Temporary Tablespaces）​ innodb的临时表空间分为session临时表空间和全局临时表空间。session临时表空间用于存储用户创建的临时表和mysql系统优化器创建的临时表（8.0.16+）。全局临时表空间(ibtmp1)存储了用户定义临时表的回滚信息段（segment）MySQL使用B+树索引组织表，树有非叶子节点作为稀疏索引用于查询叶子节点，叶子结点存储实际索引和数据；如果将这两部分一起存储，将会出现大量随机IO，因此innodb引入段的概念，常见的段有数据段、索引段、回滚段等。段是一个逻辑上的概念，并不对应表空间中某一个连续的物理区域，它由若干个完整的区组成（还会包含一些碎片页），不同的段不能使用同一个区。存放叶子节点的区的集合就是数据段，存放非叶子节点的区的集合就是索引段。每个索引在Innodb中都会存在于2个段，一个是B树中的非叶子结点，用于索引数据（索引段），另一个是叶子节点，存储实际的数据（数据段）表空间中的段初始化时会一次性分配32个页，之后再次分配空间时将以区为单位，对于比较大的段（类似LRU思想）Innodb最多一次分配4个区。区（extent）n个页组成了一个区，页大小不同时n也不同，当页大小&amp;lt;=16k时，一个区即1M（64个连续16k、32个8k…），页大小为32k时，区大小为2M，64k时，区大小为4M。使用SHOW TABLE STATUS 统计表空间中的空闲空间时，Innodb会统计所有的空闲区大小，需要注意的是，Innodb会预留一些区用于清理以及其他内部操作，这些区是不算入空闲区的页（page）页是innodb进行读写的最小存储单位，默认大小为16k，可以通过设置innodb_page_size修改。数据在内存和磁盘间写入写出也是也页为单位。出于不同的目的innodb设计了多种不同的页类型：FIL_PAGE_INDEX，FIL_PAGE_UNDO_LOG，FIL_PAGE_INODE，FIL_PAGE_IBUF_FREE_LIST。页由7部分组成 Fil Header Page Header Infimum + Supremum Records User Records Free Space Page Directory Fil Trailer其中，Fil Header - Fil Trailer、Page Header - Page Directory两对字段，分别用于记录对外的页信息（如属于那个space或log、pre和next页指针、页的checksum以及和页开头的LSN以标识页结束）和对内的页信息（如页内有多少条记录、空闲区域指针、按索引递增顺序组织的位置指针以便二分查找），Infimum + Supremum Records用于记录下限和上限，User Records用于记录用户数据，Free Space用于分配新数据。Innodb采用稀疏槽来维护索引位置指针，即并非每个数据的索引都会在Page Directory里面有记录（full page每6条记录有一个slot），因此，在record里面的extra字段中需要借助n_owned来标识有几条记录属于当前slot/record记录（record）一条记录即对应物理意义上的一行数据，只是一个record存的除了一行数据，还有一些信息用于维护这行数据，这些数据共同组成了一条record逻辑上，record由3部分组成（物理组成取决于row format，略有差异） Name Size Field Start Offsets (Number Of Fields * 1) or (Number Of Fields * 2) bytes Extra Bytes 6 bytes Field Contents depends on content（包括系统字段、用户自定义字段） Field Start Offsets记录了字段在Field Contents的起始位置，Field Contents记录了系统的以及用户定义的字段（使用相应字符集编码），Extra Bytes用于维护当前记录是否删除、在整个页中的位置、字段数目、页中下一条record记录地址等信息数据存储的物理结构：数据存储在介质上，要么按照其本身的逻辑结构组织，要么基于读写性能、存储效率等考虑做特异性存储（如映射、倒排索引等）。显然，对于常见的数据及场景，前一种方式更具有普适性，而MySQL正是使用这种方法组织数据的物理结构–将数据逐行存储。对于存储的每一行数据，是一个字段一个字段紧挨着存放并以下标来记录字段的开始结束，还是用分隔符将各个字段分隔后存放，或者数据紧挨存放并按照实际数据类型记录长度信息用于索引，这种不同的存储形式就是行格式。MySQL最小存储单位为页，读写以页为单位进行，页中有一行一行的数据。由于MySQL使用页作为最小的访问单位，当行内业务数据太大就会导致一页只能放一行甚至一行都存储不了，这样存储结构B+树将退化为链表，不利于高效的读写访问，因此，MySQL的每一页数据内最少有2行数据，当行数据过于长（一页无法存2行），将会对某些字段拆分存储，原始行仅存储部分信息，而具体拆分策略取决于行格式。行格式决定了MySQL中的数据在磁盘上的物理结构，InnoDB存储引擎支持4种行格式（5.0.3 - 5.6版本的默认行格式是COMPACT，5.7+改为DYNAMIC，可通过innodb_default_row_format参数更改） 行格式 紧凑存储 增强变长列存储 大的前缀索引支持 压缩支持 支持的表空间类型 REDUNDANT 否 否 否 否 系统表空间、独立表空间、通用表空间 COMPACT 是 否 否 否 系统表空间、独立表空间、通用表空间 DYNAMIC 是 是 是 否 系统表空间、独立表空间、通用表空间 COMPRESSED 是 是 是 是 独立表空间、通用表空间 Redundant行格式Redundant行格式主要为了兼容老版本（5.0以下）的MySQL，行数据如下：Redundant行格式顺序存储每一列数据，通过逆序存储的字段偏移列表实现不同字段的区分，同时使用6字节的头信息来记录向下一行的指针和维护行级别的锁，头信息的最后2个字节记录指向下一条记录的header尾部的指针 聚簇索引记录包含所有的用户定义字段，同时会有事务ID列和回滚指标列来支持事务及实现回滚，另外如果表没有定义主键，则在聚簇索引列中的RowId是由MySQL生成一个6字节的id，否则RowID存储主键 二级索引记录会包含不在该索引内的所有的主键列。 超大字段拆分方式：对于超过768字节的数据列，Redundant行格式的拆分策略为存储前768字节，然后是20字节的列实际长度和溢出页地址指针（同Compact行格式，见下图） Compact行记录格式如下Compact行格式相比Redundant行格式，以CPU占用的提升换来了存储占用降低20%左右，适用于IO密集型和缓存命中率较低的应用场景。行数据如下：Compact行格式也是顺序存储每一列数据，不过它通过变长字段长度列表、NULL标识位、记录头信息中的字段长度来区分每一个字段，同时使用5字节的头信息记录指向下一行的指针和维护行级的锁(详细作用机制待补充)，头信息的最后2个字节记录指向下一条记录的header尾部的指针，头信息详细如下图 Compact行格式使用变长字段长度列表来维护所有可变长度字段的实际长度（逆序存储，每个字段占用1-2字节来存储长度，所有列长度固定时，该字段不存在），使用NULL标识位来记录字段是否可以为NULL，该字段长度为 取上限(允许为NULL的字段数 / 8)字节，即每bit表示一位（逆序存储，当所有列NOT NULL时，该字段不存在） 记录头信息包含了可变长度字段信息（变长字段长度列表、NULL标志位），其后跟着非空字段（空字段除了在NULL标识位中占位，不占用实际存储空间） 聚簇索引记录包含所有的用户定义字段，同时会有事务ID列和回滚指标列来支持事务及实现回滚，另外如果表没有定义主键，则在聚簇索引列中的RowId是由MySQL生成一个6字节的id，否则RowID存储主键。 二级索引记录会包含不在该索引内的所有的主键列 超大字段拆分的方式与Redundant格式一致：对于超过768字节的数据列，Redundant行格式的拆分策略为存储前768字节，然后是20字节的列实际长度和溢出页地址指针 Dynamic行格式Dynamic行格式与Compact行格式基本相同，带来了2项改进，一是改进了对于超长可变长度列存储的支持，二是添加了对大索引前缀的支持。 Dynamic行格式是基于如果一个超长字段的一部分需要离页存储，那么将整个超长字段存储在溢出页上通常能带来更高的效率这样的思想构建的，因此，相比于Compact行格式，Dynamic行格式在拆分超大字段时，将整个字段存储在溢出页，原始行仅在该字段位置存储指向溢出页的长度为20字节的指针。至于如何衡量字段是否超大，取决于字段长度和行数据的总长度，当行数据无法成为B树的节点时（单页存储少于2行，B树退化为链表），最大的字段将离页存储，直到该行可以fit一个B树节点 Dynamic行格式的支持的索引前缀长度最大3072字节 使用Dynamic行格式的表可以存储在系统表空间、独立表空间、通用表空间 Compressed行格式Compressed行格式与Compact行格式基本相同，额外添加了表和索引的压缩存储支持。 Compressed行格式的支持的索引前缀长度最大3072字节3.2、MySQL使用B+树存储数据体现在哪里？聚簇索引、普通索引都是使用B树组织，存储数据的叶子节点的页会有指向pre和next的指针（Page的Fil Header有FIL_PAGE_PREV和FIL_PAGE_NEXT），所以才说是B+树，聚簇索引记录上面存储了所有的用户定义字段（索引组织表）4、如何优化sql语句对于sql语句引起的性能问题，主要分为两大类，一是如update、delete或ddl语句引起IO猛增或其他阻塞正常sql语句的动作，造成大量正常sql无法执行，二是select语句使用不当导致sql查询时间偏高对于查询语句，通过explain分析，查看是索引使用不当还是sql语句不当，或者mysql选择的索引不当，索引使用问题和sql语句就需要优化sql语句使得命中正确的索引或者建立合适的索引；mysql选择的索引不当的情况下，可以通过force index语句强制使用合适的索引或者重建索引触发mysql选择合适的索引（后者建议在业务较轻的时间段执行，且对于大表的执行需预先评估）。通过索引覆盖减少回表操作（select了索引字段）。通过索引下推（MySQL5.6+）减少存储引擎返回给server层执行where匹配操作的数据，提升查询效率（where中有多个索引字段，一次性匹配）。对于update和delete，尽量避免大事务，尽可能的分批分次执行对于ddl，如添加索引，移除索引，添加字段，移除字段（可以不移除字段哈，就留着就行，反正不怎么占用磁盘）等。添加字段可以放在最后一个字段，以便mysql可以使用秒级加字段优化5、如何及时发现mysql线上问题？有何规避或预防手段5.1、发现线上问题发现线上问题的良好手段就是完善的监控，实现mysql实时监控可以从两方面入手，一是通过mysql自带的功能实现监控： 可以通过监控预先设置的查询或者修改语句的正确性检测mysql的健康状态 通过set global slow_query_log=1;开启慢日志监控；并设置慢日志阈值set global long_query_time=200;来启用mysql慢查询日志发现慢sql MySQL 5.6版本之后提供了performance_schema库，在file_summary_by_event_name表中统计了每次io请求的时间，表中event_name=&#39;wait/io/file/innodb/innodb_log_file&#39;为redolog的相关时间监控，event_name=&#39;wait/io/file/sql/binlog&#39;为binlog的相关时间监控，可以开启实时监控统计相关信息（注意有性能损耗，经人测试损耗在10%左右）另一个是通过监控与mysql交互的中间件实现mysql的数据监控，在数据库中间件中集成监控相关代码，对于每个sql语句的执行过程进行监控上报，如sql解析，优化器选择，存储引擎执行时间，配合相关的报警插件及时通知到开发负责人5.2、规避或预防线上问题一是从设计上尽可能规避问题，比如： 选用innodb引擎，以达到crash-safe的目的、实现对事务的支持； binlog使用row格式（除了某些极个别固定场景使用statement或mixed），以保证支持其他业务准确使用binlog； 隔离级别选用rc（配合使用row格式的binlog），支持事务的同时最大限度的提升并发度（需要注意业务对rr或其他隔离级别没有严格要求）二是在使用过程中尽量规避问题，这个主要通过建立并严格遵守完善的sql规范来实现。如： 禁用join操作 分页查询最多查询5w条 线上禁用触发器及外键（此类操作具有隐蔽性，不利于后续维护） 禁止批量操作大批数据（分批分次执行，如每次200条，执行100次） 尽量避免大事务（如一次性删除100w数据） 事务中最耗时的sql操作放在最后 尽量避免数据库做大量复杂的计算操作（将计算操作放在易于横向扩展的server层） ddl语句必须走工单执行，事前进行时间、影响范围评估，尽量放在业务较轻的时间段执行 修改数据行为必须走工单执行，工单必须有回滚脚本，且说明修改前后影响 上线select语句前进行explain评估，尽量使用索引及索引覆盖等优化技术，避免使用文件排序、全表查找5.3、为何mysql默认的隔离级别是RR，实际生产中你们使用了什么隔离级别，为什么隔离级别有四个，读未提交、RC、RR、序列化，序列化性能太差，读未提交存在脏读问题，因此RC和RR比较适合作为默认隔离级别。对比RC和RR，配置RC隔离级别、statement格式的binlog时，在出现事务乱序时，备库重放SQL会导致主备数据不一致，所以MySQL选择了RR作为默认隔离级别。实际使用中大多选择了RC，相比RR，一方面使用RC时仅需加行锁即可，可以提升访问并发度，另一方面无需加gap lock，锁定的范围较小（只有当前行），产生死锁的概率大大降低6、mysql有哪些比较棒的设计思想，在哪些场景下运用该思想获得了性能提升 随机操作优化成顺序操作从而大幅提升读写性能。根据空间局部性原理，通过redolog将随机写入优化为顺序写入；通过changebuffer将随机读取变为顺序读取；应用rowlog时如果隔壁的数据也是脏数据，将触发数据merge；范围查询时筛选出符合条件的id值放入read_rnd_buffer递增排序后到主键索引树查询记录明细并返回（MRR）；join操作中运用MRR优化将NLJ优化为BKA； 通过缓存数据大幅提升查询性能。根据时间局部性原理，buffer poll维护lru数据，以加快最近访问的数据的查询效率 单次操作改为批量操作以提升效率。如binlog和redolog写入时，可以通过设置sync_binlog=N（N&amp;gt;1）累计N个事务后执行fsync触发刷盘；设置innodb_flush_log_at_trx_commit=2触发事务提交时仅将redolog写入page cache，由文件系统自行控制批量将page cache写入磁盘而不是直接写入磁盘（innodb_flush_log_at_trx_commit=1）7、各种概念区分rowId、commit_id、trxId、Xid、LSN、GTID、threadIdrowId：当用户未指定表的主键且没有非空唯一键时，Innodb生成一个6字节的rowId（循环使用）作为当前记录主键（注意：有非空唯一键则非空唯一键为主键，多个唯一键时，使用第一个唯一键的字段作为主键。唯一键一定要定义为非空，唯一联合索引的每一个字段也一定要是非空，不然有null字段时看起来是一样的，但是MySQL认为是不一样，插入了不唯一数据）commid_id：事务提交时，生成对应的commit_id。当启用redo log的组提交时，同一组提交的事务具有相同的commit_idtrxId：Innodb的事务id，事务开始时申请的，按照申请顺序严格递增，用于标记不同的事务。当事务修改某条记录时，trx_id将会写入该记录的row_trx_id中，表示当前数据由trx_id生成，同时在undo log中也会记录当前undo log对应的是哪个trx_id，用于在其他事务需要查看当前数据的历史版本时计算。Xid：server层的事务id。内存维护global_query_id（8字节，循环使用），赋给query_id，第一个事务的Xid即为query_id，实例重启后生成新的binlog文件，顾同一binlog文件内事务的Xid不同，不同事务的Xid可能相同（循环使用）LSN：全称log sequence number，单调递增，用来对应redo log的一个个写入点。每次写入长度为length的redo log， LSN的值就会加上length。LSN会记录在数据页的Fil Header的FIL_PAGE_LSN字段中，用于表示当前页最近的一条log记录；同时也会记录在文件的第一页的FIL_PAGE_FILE_FLUSH_LSN中标识已刷新到磁盘的最大LSN。GTID：全称Global Transaction Identifier，也就是全局事务ID，是一个事务在提交的时候生成的，是这个事务的唯一标识。它由两部分组成GTID=server_uuid:gno。用于主从架构下，主库故障，从库上线切换过程同步数据的过程。同步数据原来有基于位点的同步，需要开发人员手动识别、跳过故障sql位点、建立新的同步关系，操作复杂。MySQL5.6引入GTID的概念，使用GTID标识一个全局唯一事务，使用基于GTID的同步时，只需要开发人员修改主从关系建立新的同步关系即可，MySQL将检查新的主从关系间GTID的包含关系，实现事务同步threadId：当前session的线程id，在创建临时表时，临时表在内存中的唯一区分(db+table+serverId+threadId)需要用到，且主从复制时，相应临时表的binlog记录也会将threadId传递给从库change buffer、insert buffer、log buffer、sort_buffer、join_bufferchange buffer：当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InooDB会将这些更新缓存在change buffer中，这样就无需从磁盘中读入这个数据页了在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作。将change buffer中的操作应用到原数据页，得到最新结果的过程称为merge。除了访问这个数据页会触发merge外，系统有后台线程会定期merge。在数据库正常关闭（shutdown）的过程中，也会执行merge操作。change buffer在内存中，有buffer pool分配空间，可以通过参数innodb_change_buffer_max_size来动态设置大小。这个参数设置为50的时候，表示change buffer的大小最多只能占用buffer pool的50%。持久化到磁盘时，change buffer写入到系统表空间唯一索引的更新不适用change buffer，因为必须将数据写入内存判断唯一性约束。使用change buffer时，当页内需要merge的记录越多，节约的开销越大，性能改善越明显，反之，非但不能改善，反而带来性能损失。因此，change buffer适用于账单类、日志类这种写完以后马上被访问到的概率比较小的系统，对于写完之后很快就要访问的数据不适用change bufferinsert buffer：change buffer的前身，仅针对insert优化（非主键的非唯一索引有效），之后升级了，增加了对update/delete的支持，并改名为change bufferlog buffer：log buffer是日志写入磁盘前保存日志的内存区域，这些数据会定期写入磁盘。该内存区域大小由innodb_log_buffer_size 决定，默认16M，大的log buffer允许执行修改大量数据的事务在提交前仅写内存，因此，如果在特定场景需要执行大量的大事务，可以适当提高这个缓存。innodb_flush_log_at_trx_commit变量定义了log数据write和fsync的时机，innodb_flush_log_at_timeout 变量定义了刷盘频率。sort_buffer：使用Explain查看执行计划时，在Extra中可能会有Using filesort，表示需要排序，MySQL给需要排序的线程分配一段内存用于排序，这块内存就是sort_buffer，大小由sort_buffer_size决定，排序数据（select的所有数据）超出该大小就会使用磁盘临时表来辅助排序，这就是全排序。max_length_for_sort_data字段决定了要排序的数据是否太长而启用rowId排序，启用rowId排序时sort_buffer仅存储要排序的字段和主键id，排好序后回表取出select的字段返回join_buffer：join_buffer与sort_buffer类似，是在需要做join操作时，MySQL给相应的线程分配的内存块。join_buffer的大小是由join_buffer_size决定，默认256k。a、b做join，a符合条件的放入join_buffer，b和buffer中数据比较，取得结果集。当join_buffer的大小不足以放下所有满足条件的a记录，则分段处理（一段一段放入buffer，做join，处理结果集）buffer pool、double-write bufferbuffer pool（bp）是InnoDB引擎在内存中开辟的一块用于缓存数据和索引的区域。上文提到的各种buffer，MySQL的数据页缓存就存储在bp中。在bp内部，使用变种的LRU算法管理list结构的数据。详细参考这篇还没写的文章double-write buffer是Innodb在将buffer pool里面的页数据写入到适当的磁盘文件前的数据存储区域，它是存储在系统表空间的一块区域（8.0.20+移出系统表空间独立存储了）。主要是为了应对在写page（默认16k）到一半（磁盘一般默认4k）情况下系统宕机的情景，此时可以在double-write buffer中找到对应的数据备份用于故障恢复。原理是：在将bp中的页写入磁盘对应的文件前，先将bp中的页copy到double-write buffer，然后将double-write buffer内存中的数据每次1M，顺序的写入double-write buffer对应的磁盘文件上并立即调用fsync函数刷磁盘，double-write buffer写磁盘完成后，再将double-write buffer中对应的页写入这个页本身所属的磁盘文件（例如数据页）通过上述的过程可以看到，虽然做了数据copy，但是并不会造成2倍的IO增加，因为数据是以一个个顺序的大块执行写入并调用单次的fsync刷新到磁盘上的。redo log、undo log、binlog、row log、relay logredo log：redo log是基于磁盘存储的用于在系统crash之后恢复因为未完成的事务操作而损坏的数据的数据结构（redo log在内存中有redo log buffer对redo log缓冲，用于提升性能）。redo log是Innodb独有的特性，是Innodb存储引擎实现crash-safe功能的核心。redo log主要记录了事务对数据页(Page)的物理修改，在固定大小的磁盘文件上顺序存储，采用循环写的方式。redo log是物理逻辑结合型的日志，具体是哪个page是物理操作，而page内的变化是逻辑操作；这种方式既实现了物理日志的幂等性（以实际存储页为整体），又拥有逻辑日志的轻量性（页内修改是逻辑日志）。当有数据变更时，就会记录一条redolog到文件中(实际是先写buffer)，同时，在redo log文件中存在一个称为checkpoint的位点，这个位点标记了已刷盘和未刷盘的redo log分界，已刷盘的日志可以被新的redo log覆盖，未刷盘日志不能被覆盖，当所有日志都未刷盘，更新等操作将无法继续进行。checkpoint实际标记的是相应位置的redo log的LSN，而不是位置信息，LSN全称Log Sequence Number，递增数字，每条redo log都会分配一个LSN。使用redo log进行崩溃恢复时的流程： 如果redo log里面的事务是完整的，即已经有了commit标识，则提交 如果redo log里面的事务只有prepare，则通过XID到binlog文件中找到binlog判断binlog完整性 binlog完整，则提交事务 binlog不完整，回滚 判断redolog是否完整是通过是否有commit标识，那判断binlog是否完整是通过什么呢？ binlog有相应的格式，statement格式在结尾有COMMIT，row格式在最后有XID eventredo log如何关联对应的binlog？ redolog和binlog有一个共同的由server层生成的事务id字段-XID，崩溃恢复时，扫描redolog，有commit的就直接commit，没有commit只有prepare的就拿着XID找binlog。binlog：binlog是MySQL server层实现的逻辑日志，无论什么存储引擎，都会有binlog产生，实现主从复制的日志文件（表空间是Innodb的概念，binlog是MySQL server层实现的日志）。它是增量写文件，可以根据大小、时间切割，以方便恢复数据。binlog有3种格式 statement：记录原始的sql语句，丢失了修改前的数据，且无法和RC隔离级别一起使用（事务乱序可能导致主从数据不一致），生产中使用不多 row：记录数据完整的修改前和修改后，占用空间大，但是信息详细，普遍应用于实际生产中，生产中有大量依赖binlog修改前后值来实现业务逻辑的场景 mixed：结合以上两种，如果可能引起主备不一致就用row，否则用statement，使用较少的原因还是信息不够完整undo log：undo log是用来支持实现一致性读的数据结构。它记录了如何undo事务对聚簇索引记录的最近的修改，当其他事务要看当前记录的原始版本时，可以通过undo log计算出origin data。undo log存储在rollback segments中的undo log segments中，rollback segment存储在undo表空间和临时表空间。row log：使用alter table A engine=Innodb重建表过程中，对原始表的更新操作日志记录relay log：主从同步时，将主机的binlog同步到从机的relylog中，然后从机读取relylog恢复数据sync_binlog、innodb_flush_log_at_trx_commitsync_binlog：控制binlog的write（binlog写入Page cache）和fsync（Page cache持久化到硬盘）时机 binlog cache –&amp;gt; page cache –&amp;gt; hard disk sync_binlog=0的时候，表示每次提交事务都只write，不fsync； sync_binlog=1的时候，表示每次提交事务都会执行fsync； sync_binlog=N(N&amp;gt;1)的时候，表示每次提交事务都write，但累积N个事务后才fsync； innodb_flush_log_at_trx_commit：控制redolog的write和fsync时机 redo log buffer –&amp;gt; page cache –&amp;gt; hard disk 设置为0的时候，表示每次事务提交时都只是把redo log留在redo log buffer中; 设置为1的时候，表示每次事务提交时都将redo log直接持久化到磁盘； 设置为2的时候，表示每次事务提交时都只是把redo log写到page cache；anaylize table、optimize tablealter table t engine = InnoDB是重建（recreate）表，将会创新新的临时表，然后复制数据，修改临时表名称为原有的表名。从5.6引入OnlineDDL起，就允许在执行期间执行增删改操作，只是不能执行其他DDL（持有MDL读锁），而且执行期间对原表的修改也会记录在row log中，执行完成后，应用row log到新表analyze table t 不是重建表，只是对表的索引信息做重新统计，没有修改数据，这个过程中加了MDL读锁optimize table t 等于recreate+analyzemvcc全称Multi-Version Concurrency Control，同一条记录在数据库中可以存在多个版本就是MVCC。MVCC的实现：mvcc通过read-view和undo log来实现。每条记录存储生成当前版本的trx_id（事务id），记为row trx_id，每条记录有undo log，undo log记录了如何将当前数据回退到某个特定版本（特定row trx_id的版本）。事务启动时（RR，RC是每条语句执行时），创建一致性视图（由当前正运行未提交的事务id数组和系统已分配的trx_id+1共同组成），然后根据需要确定使用当前版本数据或者使用通过undo log计算出的历史版本数据（快照读，则读快照数据；当前读，则读当前数据），从而实现了在多个版本同时存在的情况下并发的访问刷脏页脏页指的是内存中已经修改了数据页，这些数据页在同步回磁盘上之前和磁盘数据不同，称为脏页（对应的，内存和磁盘数据相同的页称为干净页）。将脏页同步回它在磁盘上的对应的页的过程，称为刷脏页。刷脏页的时机有： redo log文件写满了，需要将checkpoint向前推进。此时就需要将checkpoint向前推进的位置上的所有redo log中在内存对应的脏页刷盘 内存不足，或者是bp中的部分数据页被驱逐，此时如果被驱逐的数据页是脏页，则驱逐前也要刷脏页 系统空闲时刷脏页。innodb使用innodb_io_capacity来表示当前磁盘最大的IO能力，Innodb通过控制脏页比例和redolog写盘速度来控制刷脏页速度。脏页比例要多关注，不要经常超过75%。刷脏页有连坐机制，脏页隔壁页也是脏页则会一起刷，使用SSD时可以修改参数innodb_flush_neighbors关闭连坐机制 MySQL关机前半同步（seni-sync）默认配置下，MySQL主从库通过binlog来保持一致，主库事务提交后，将binlog日志写入磁盘，然后返回给用户，备库通过拉取主库的binlog来同步主库的操作，无法保证主备节点数据实时一致，只能保证最终一致，因此属于异步复制。为保证在主备切换时，主备节点数据完全一致，MySQL提供了半同步复制，其实现原理为：事务在主库上执行完成，生成binlog并推送给备库，等待备库的ack消息，主库接收到备库的确认消息后，在返回给用户，事务完成。半同步分为after-commit和after-sync两种：after-commit：主库将事务commit之后，将binlog发给从库并等待ack，然后返回（从库commit前主库变更可见）after-sync：主库将binlog发给从库，收到ack后，本机commit提交，然后返回（所有机器几乎同时commit）8、知识点关联LSN和redo log、checkpoint的关系LSN全称Log Sequence Number，递增数字，每条redo log都会分配一个LSN。当有数据变更时，就会记录一条redolog到文件中(实际是先写buffer)，同时，在redo log文件中存在一个称为checkpoint的位点，这个位点和write position之间标记了未刷盘的数据，其余的是已刷盘的redo log，已刷盘的日志可以被新的redo log覆盖，未刷盘日志不能被覆盖，当所有日志都未刷盘，更新等操作将无法继续进行。checkpoint和write position实际标记的是相应位置的redo log的LSN，而不是位置信息。快照读、当前读快照读指的是在某一时刻创建快照，后续的读取操作以这个快照中的数据为准。比如RC或者RR启动事务时创建的语句级快照（每条语句执行前算出新的视图）和事务级快照（事务开始前创建快照），后续事务中的读语句只能看到快照中的数据当前读指的是读取的数据一定是当前最新的（假如有数据正在更新未提交，此时因为要获取S/X/行锁，所以会等待行锁释放后继续操作）。更新操作需要先读后写，这里是当前读。加锁的select操作也是当前读select k from t where id=1 lock in share mode;（S锁，共享锁），select k from t where id=1 for update; （X锁，排他锁）99、还有哪些地方不尽如人意或可以改进的对于MySQL的二次开发和深度使用涉及不够，就不班门弄斧了参考：https://dev.mysql.com/doc/refman/8.0/en/https://dev.mysql.com/doc/internals/en/MySQL45讲-极客时间MySQL行格式MySQL的内存结构与物理结构" }, { "title": "AQS学习纪要", "url": "/posts/AQS%E5%AD%A6%E4%B9%A0%E7%BA%AA%E8%A6%81/", "categories": "work, 利其器", "tags": "J.U.C, 学习纪要", "date": "2022-09-07 06:46:49 +0800", "snippet": "本文（以ReentrantLock为例）记录下AQS学习纪要 AQS维护了state字段，通过原子的CAS修改state，实现“多个线程抢占锁”这一语义，同时对于等待抢占锁的多个线程使用CLH队列的变种-FIFO双端队列来维护，通过park(thread)来确保未抢占到锁的线程等待下次抢占锁。释放锁时，同样CAS修改state，并unpark(thread)唤醒等待的线程1、数据结构AQS维护了以Node为节点的CLH变种的FIFO队列，尾部入队，头部出队，等待锁时入队，获取到锁后出队。/** &amp;lt;pre&amp;gt;* +------+ prev +-----+ +-----+* head | | &amp;lt;---- | | &amp;lt;---- | | tail* | | ----&amp;gt; | | ----&amp;gt; | |* +------+ +-----+ next +-----+* &amp;lt;/pre&amp;gt;*/AQS的ConditionObject维护了在某个等待条件上的线程等待队列，并在适当时机将节点转移到CLH队列上，并由解锁操作唤醒线程继续抢锁、运行等/** &amp;lt;pre&amp;gt;* +------+ nextWaiter +-----+ +-----+* firstWaiter | | --------&amp;gt; | | --------&amp;gt; | | lastWaiter* +------+ +-----+ +-----+* &amp;lt;/pre&amp;gt;*/2、定义底层实现，提供上层接口调用链路：自定义lock ** -&amp;gt; acquire -&amp;gt; **tryAcquire -&amp;gt; addWaiter -&amp;gt; acquireQueued自定义unlock -&amp;gt; release -&amp;gt; tryRelease -&amp;gt; unparkSuccessor自定义同步器提供对外接口，并实现tryAcquire-tryRelease或tryAcquireShared-tryReleaseShared逻辑完成自定义的加锁、解锁过程，AQS的acquire会调用tryAcquire方法，并完成底层逻辑。AQS的release调用tryRelease方法，并完成底层逻辑。3、问题详解： AQS部分变量预览 Node.waitStatus 1：CANCELLED 0：初始化 -1：SIGNAL -2：CONDITION3.1、加锁时未获取到锁的线程在干嘛？（怎么加锁？）多个线程调用lock方法，同时抢CAS设置state，成功的进入业务逻辑，失败的，将当前线程包装成Node（waitStatus=0）加入AQS（或者说ReentrantLock实现的Sync类）的等待队列（CLH变种的FIFO双端队列）队尾，入队后，执行acquireQueued(node, arg)，此时进入自旋过程，自旋代码中，先判断是否为头节点及抢占CAS设置state（成功代表加锁成功，退出），然后判断pre节点的waitStatus，为0的话最终会赋值为-1，然后就会park(this)，当前线程进入等待，此时加锁过程完成。抢到锁的线程执行业务逻辑，未抢到锁的线程全部park(this)等待唤醒。3.2、释放锁时等待加锁的线程如何感知到？又是如何获取到锁的？（怎么解锁？）持有锁的线程调用unlock()，会在state上减去的每次lock时CAS加的值，直到state为0，代表可重入锁全部解锁，开始unpark(head.next.thread)，（head为占位节点，不代表任何线程的），此时CLH队列的第一个线程将再次进入自旋过程，即释放锁后，下一个线程将会CAS成功设置state，加锁成功3.3、await()、signal()是如何与上面的机制打通的？（等待通知是怎么运作的？）await()和signal()和上述的加锁、解锁不太一样，加解锁会有独占、非独占的区分，但是await/signal一定是独占的，此时AQS内部类ConditionObject使用单链表来维护在condition上等待的Node（线程）队列。3.3.1、await()是让当前线程进入等待状态:await会将当前线程包装为Node（waitStatus=-2），加入到等待队列（单链表）的队尾，然后将当前的state完全释放（此为释放锁），接下来进入自旋：判断当前节点是否在Sync队列（CLH队列）中 waitStatus为 CONDITION 或者 pre 为null，则肯定不在 next != null则肯定在了（ConditionObject的单链队列通过nextWaiter维护链表关系，pre和next是CLH队列使用的） 如果以上还没有，那可能是enq里面CAS设置节点失败了，此时从尾节点向pre找，找到就有，而且大概率在尾节点附近 // enq(Node)方法部分代码 node.prev = t; // pre已经接上了 if (compareAndSetTail(t, node)) { t.next = node; return t; }不在Sync队列，则park(this)，当前线程进入等待状态。当signal将Node放到CLH队列中之后，跳出自旋，执行acquireQueued(node, savedState)尝试恢复之前释放的锁，这里就进入了加锁的流程，加锁成功则继续执行，加锁失败，则在CLH队列上等待下次抢占锁3.3.2、signal()是唤醒在相应condition上等待的线程：signal首先（判断当前线程是否拥有锁就不提了）对当前condition的队列的队头head，执行doSignal方法，先把head从队头移除，然后CAS修改waitStatus为0，然后把head加入到AQS的双端队列队尾，接下来如果它的pre节点的状态&amp;gt;0（1）就设置为-1，失败了就unpark(node.thread)，主动调起线程触发更新pre为-1（此处有点疑问啊，不应该无论任何时候都unpark么？让await()继续运行啊，为什么正常情况下不做unpark的）。这里不做unpark是对的，unpark是unlock做的事情，执行完signal之后就已经将节点（线程）移动到CLH上面了，等待释放锁之后，await才有可能设置成功state。3.4、待解决问题：acquireQueued()中finally代码段里面何时failed=true，另外，执行cancelAcquire(node)时没有对node本身的状态做任何判断，那假如我要手动取消获取锁，怎么取消？？（待补充）4、数据流转&amp;amp;state变更整理：5、引用参考aqs-theory-and-applyAbstractQueuedSynchronizerReentrantLockJava多线程编程核心技术" }, { "title": "行为型模式", "url": "/posts/%E8%A1%8C%E4%B8%BA%E5%9E%8B/", "categories": "work, 利其器", "tags": "design pattern", "date": "2022-09-01 09:49:59 +0800", "snippet": "责任链模式  使多个对象都有机会处理请求，从而解耦请求的发送者和接收者。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。责任链适用于有多个业务侧处理，且需要动态的决定使用哪个业务处理的场景。责任链的变种-管道模式在实际生产中使用较为广泛，区别在于，严格的责任链模式，链上只有一个业务来处理，而管道模式是将对象流过管道中的所有阀门，每个都处理一遍。生产中适用于网关中间件的数据预处理、大数据中的数据清洗、广告业务中的打点计费处理、分销业务中的多级分销计算等责任链模式中由于需要在链上传递信息，所以一般会有上下文作为参数，保存输入、输出、状态等信息传统的责任链模式如下：这种方式每个handler自行维护next()节点，整个链路只有一个handler处理请求。这种方式无法灵活的添加、移除节点，同时各个节点的顺序散落在各个handler中，不便于后期维护，可以使用单独的List&amp;lt;Handler&amp;gt;来维护链，然后client依次调用各个handler，解决以上两个问题。对于需要每个handler都对数据进行处理的场景，可以考虑责任链模式的变种-管道模式，如下图所示todo（UML &amp;amp; demo）命令模式​ 指将请求封装为一个对象，以便参数化表示客户请求、对请求排队、记录请求，并且支持可撤销操作。命令模式可以和观察者、状态等模式结合实现功能。实际生产中比较常见的是Redis的cli和server交互时使用命令模式；还有Runnable也是命令模式的实践（通过Runnable对象封装了实际的run()逻辑，传递给Thread完成实际的线程运行过程）该模式的核心在于将请求封装为对象并交由第三方Invoker或Caller执行，实际执行逻辑在command对象和要处理的question中，通常核心逻辑在question中，command对象仅做“开场准备”和“打扫战场”，极端场景command什么都不做，仅仅是调用传递。当然，对于静态的question，封装太多的业务逻辑也不太合理，这种情况可以使用中介者模式添加中介，封装为question的处理类，收敛核心处理逻辑的同时避免静态question对象的职责无限外延解释器模式​ 解释器模式通常用来解决特定的、出现频率足够高的问题，通过将问题的各个实例描述为一个表达式，给出表达式的通用解释（可能是查找匹配规则、可能是运算规则），解释该表达式后得出结论（问题的解）。解释器的核心在于使用类来表示每一条规则（解释），非常方便修改、扩展规则。生产中常见的是正则匹配，如java.util.Pattern，自定义算术、逻辑运算规则，还有就是在规则中心非常常见，用于解释执行各种自定义规则文本迭代器模式​ 迭代器常见用于访问各种容器，在不暴露容器内部实现的基础上完成容器内元素的遍历。迭代器分为内部迭代器和外部迭代器，外部迭代器由客户主动获取下一元素，内部迭代器仅需客户提交待执行动作即可。迭代器的实现通常与容器本身的数据结构相关。中介者模式​ 中介者模式用一个中介对象来封装一系列的对象交互。通常情况下，当系统当前的抽象层次无法很好的应对业务的复杂性导致部分逻辑或者部分职责混杂时，中介者模式就可以登场了，此时我们使用中介者模式来增加抽象层次，将混杂的部分逻辑或者混杂的职责进行划分，将部分逻辑与职责划分到新的中介者层次中，由中介者来完成相应对象的交互。在上面命令模式的解释中，就有这种场景的存在备忘录模式​ 备忘录模式顾名思义，为对象建立备忘记录，以方便后续恢复，当然，是在不破坏对象的封装性（不暴露对象的实现细节）的前提下。实际的工作中，很少有这种需要在不暴露对象实现细节的前提下给对象建立内存备忘记录的场景，一般需要存储时都会使用存储中间件，至于本地缓存的情况，虽然与备忘录模式手段相似，但目的相差甚远。因此，笔者实际工作中遇到的相应场景较少，理解不足，暂时不展开，待后续补充观察者模式​ 观察者模式用于实现发布-订阅功能，当对象状态变更时，订阅了对象变更的用户都将得到通知，且通知的对象和被观察的对象没有强耦合。实际生产中，这种发布-订阅的应用非常常见，小到多渠道通知（如站内消息、短信、消息推送）、大到商品变更订阅，都是观察者模式的运用，只是在实践中，如何运用也差别巨大。比如类似多渠道通知这种，使用观察者模式有些重，更大的挑战在通知的多样性，而不是通知渠道的多寡，因此这种场景使用与否就看开发者个人了；而类似商品变更订阅、订单状态变更订阅，则要健壮的多的多，通常不会使用这种内存式的观察者模式，而是在引入中间件的基础上完成订阅，比如自行订阅商品变更的binlog消息完成下游逻辑、订阅订单中心包装的订单状态变更消息完成下游逻辑，这样做，一方面比之内存式的订阅要稳健的多，不会因为单机内存快速增长引起稳定性问题；同时也避免了大量业务杂糅到单机引起的内聚问题；而且在扩展性上也大大增强，方便快速的扩展软硬件以应对业务规模的快速增长状态模式​ 允许对象在内部状态变更时改变它的行为。对象看起来似乎修改了类（实际上还是原有的类，只是修改了持有的对象，以达到改变行为的目的）。实际生产中，多用于需要根据状态执行不同行为的系统，比如售后系统就可以很好的运用状态模式结合预先制定好的状态机完成售后订单的流转策略模式​ 策略模式用于在不同场景需要不同计算、存储、映射逻辑的情况下。通常预定义好不同的策略，在使用时根据当前情况选择适当的策略，完成相应的逻辑。实际生产中，该模式通常和工厂模式配合使用，常见于选择负载均衡策略、序列化方法、算法实现；对于业务流程大致相似，但又有细微差别的，通常也会选择使用策略模式实现，或者前期代码堆叠以便于快速响应，在业务膨胀之后改用策略模式以便于方便维护。模板方法模式​ 模板方法模式通过定义一个操作中的主流程骨架，将一些具体步骤延迟到子类中，从而达到不改变主流程的前提下重定义流程内某些步骤的目的。 这种模式在实际工作中大量运用，有的是出于减少公共冗余代码的目的；有的是方便业务下游自定义具体算法（比如上面策略模式，提供不同的负载均衡策略，同时支持业务方自定义策略）；有的是定义好主流程，后续只需修改子类即可完成业务需求（比如上方的管道模式，定义好管道的流程，后续仅需修改、增添不同的阀门即可）；有的是为了避免中间件切换侵入业务逻辑（将业务相关逻辑放在模板方法中）相应的案例看上面的管道模式吧，此处不再赘述访问者模式​ 访问者模式允许在不改变对象已有的各属性元素的类的前提下添加作用于这些元素的新操作。不使用访问者模式时，需要将静态对象分别传递给不同的类做处理，使用访问者模式后，关注重点变成静态对象本身，将静态对象accept各个访问者。这是两种编程的思想，一种将资源给到各个运算逻辑执行运算，一种将运算逻辑在资源上“重放”一遍完成运算。visitor模式有效的避免了将单个静态对象从头传到尾的情况，定义不同的visitor，使静态对象接受或应用不同的访问者完成业务逻辑。笔者实际工作中遇到的相应场景较少，理解不足，暂时不展开，待后续补充" }, { "title": "结构型模式", "url": "/posts/%E7%BB%93%E6%9E%84%E5%9E%8B/", "categories": "work, 利其器", "tags": "design pattern", "date": "2022-09-01 09:49:49 +0800", "snippet": "适配器模式​ 通过适配器使得拥有不兼容接口的类完成无缝对接，适配器将目标类和适配者解耦，增加了类的透明性和可复用性。适配器有类适配器和对象适配器。类适配器通过继承目标类并实现适配者实现；对象适配器通过对象组和实现适配。适配器的一大问题是过多的应用容易造成逻辑意义的混淆，大大降低了代码的可读性。对于类适配器，当需要适配的类增多时，实际生产中一般通过对于不同的目标类使用策略模式达到无缝对接。对于对象适配器，当需要适配的对象急剧增多时，一般通过增加新的对象适配器，并划分层次、职责来达到逻辑清晰、方便维护的目的，如果新增对象适配器依然无法有效解决（适配对象实在太多了），往往需要在逻辑架构上进行调整，并引入类似策略模式、工厂模式、模板模式等拆分相应的对象适配器，如果这样还是不行，那说明整个架构有问题啊，核心代码都堆到一起了，需要好好考虑下当前这种方式是否合适了桥接模式​ 将抽象部分与实现部分分离，使他们都可以独立的变化。显然，Java的多态是实现桥接模式非常好的手段，上述中抽象工厂的子类的实现即是桥接模式的应用组合模式​ 显然，无论是自定义多个属性或者维护一个对象集合，都是组合模式的运用。组合模式使得client对单个对象和组合对象的使用具有一致性。装饰者模式​ 通过对现有的类进行包装，以达到不修改已有类的基础上增加新的功能的目的。在实际生产中，在包装RPC接口中广泛使用，通过wrapper的方式，在不修改已有接口的情况下，对二方包的rpc接口添加异常封装、降级等功能门面模式​ 通过为一个复杂的子系统提供对外的简单门面接口，屏蔽子系统的复杂性，降低各系统之间的依赖。实际生产中，外观模式在上述装饰者模式应用场景中，再往上靠近业务的一层中使用比较普遍享元模式​ 运用共享技术有效地支持大量细粒度的对象。最常见的就是Java中的Integer类持有0-128的数字对象，以加快valueOf(int)方法的访问速度；实际生产中比较常见的是初始化一些固定的（不多，因为这种情况更合理的做法是放在配置中心去）或者是一次性的数据（嗯，这个修数据或者跑数据的时候就比较常见了，哈哈哈）代理模式​ 通过为其他对象提供一种代理以实现访问当前对象。Java代理模式的实现分为静态代理和动态代理（分为jdk动态代理和cglib动态代理）静态代理在编译前写好静态代理类代码，编译时将代理类变成class文件，一旦修改接口，则目标对象和代理对象需要一起修改jdk动态代理在运行时动态生成代理类字节码（调用时使用反射）并加载到JVM中，接口变更，仅需修改目标对象。实现InvocationHandler接口即可使用Proxy类动态生成代理，并实现代理调用。由于动态生成的代理类继承了Proxy类，java又是单继承的，所以动态生成的类如果想和被代理的类关联起来，只能通过implement接口的形式，顾使用jdk动态代理时被代理类必须是实现了某一个接口的类。cglib使用ASM技术生成代理类字节码的方式实现代理类的动态生成，这种方式由于直接操作字节码，顾没有implement接口的类也可以被代理，但是由于它生成的是被代理类的子类，顾对于final类和方法不生效，调用代理类时通过FastClass方法索引调用，比反射略快，但是方法过多时switch case效率如何有待测试。JDK动态代理是委托机制，在动态生成的代理类中委托InvocationHandler通过反射去调用被代理类的实现方法。CGLib则使用的继承机制，被代理类和代理类是继承关系，所以代理类是可以赋值给被代理类的，如果被代理类有接口，那么代理类也可以赋值给接口参考链接代理模式JDK动态代理与CGLib对比java代理模式" }, { "title": "创建型模式", "url": "/posts/%E5%88%9B%E5%BB%BA%E5%9E%8B/", "categories": "work, 利其器", "tags": "design pattern", "date": "2022-09-01 09:46:49 +0800", "snippet": "工厂方法模式&amp;amp;抽象工厂模式​ 指由工厂来创建对象，客户端仅关心传入参数。两者类似，只是抽象工厂模式抽象程度更高，可以定义不同的接口来实现不同工厂的生产接口，而工厂模式中接口只能定义自己工厂的生产接口，工厂需要生产不一样的产品时就不行了。在实际运用中，二者往往结合使用，利用抽象工厂模式的抽象程度最高来定义最顶层的抽象工厂接口，再往下是不同类别的abstract工厂，最后就是工厂模式来实现最终需要的的工厂类。单例模式​ 指一个类只有一个实例对象，对外提供一个静态公有方法获取实例。单例分为懒汉式和饿汉式。懒汉式在类加载时实例化对象。通过java类加载机制的同步来保证仅实例一个对象。缺点是增加了启动耗时，提前占用了内存。饿汉式在第一次使用类时实例化对象，需要通过DCL来保证一次性正确的实例化对象（需要用到volatile修饰对象引用，利用volatile的可见性和禁止指令重排序的特性避免new单例对象时造成引用逃逸），缺点是实现稍微复杂点。还有一种方式是使用静态内部类创建单例对象，但是最大的问题是这种方式无法传递参数。以上三种方式通过反射修改实例化对象方法(构造方法)的可见性可破坏该单例。所以可以通过枚举类来创建单例（枚举类无法通过反射创建对象）避免被破坏单例（一般情况下不至于，除非系统出现重大漏洞）。建造者模式​ 通过解耦复杂对象的构造和展示达到相同的构造过程生产不同的对象的目的。builder本身并不参与实际的参数初始化过程，而由具体的builder完成。适用于只需要构造几种特定性质的对象，且对象具有较多属性不便于通过构造函数完成初始化过程。原型模式​ 适用于需要消耗大量的存储或比较耗时的对象创建过程；或者用于简化创建多个相同对象或者创建具有大多相同属性的对象。（创建对象时传入同类型的对象，并通过clone接口实现对象赋值，以简化创建对象的过程）" }, { "title": "Design Pattern Overview", "url": "/posts/DesignPatternOverview/", "categories": "work, 利其器", "tags": "design pattern", "date": "2022-09-01 08:16:49 +0800", "snippet": "设计模式概述​ 伴随着计算机的发展，编程也从低级的汇编语言逐步发展到高级语言，从面向过程逐步转化到面向对象，这些演进最终都达到了提高效率的目的。在面向对象软件设计的过程中，为了达到以不变应万变或者以微小的变化响应多变的需求，大量有经验的工程师逐步总结出了一些通用的模式以尽可能的复用已有的代码，这就是设计模式。​ 设计模式是针对开发中常见的一些问题的解决方案，是大量的工程人员根据长期的试验总结出来的一种最佳实践。设计模式来源于实践，并反哺实践，以最佳实践为准则，对于不同的实践场景，可以针对性的做相应的修改，以最大程度的满足需求。使用设计模式的目的是为了增强代码的复用性，扩展性。本系列文章接下来结合笔者在工作中的实践和GoF book中的相应模式做一些简单的总结记录。​ 在了解具体的设计模式之前，先来看看一些常用的面向对象设计原则常见的面向对象设计原则（各设计原则并不是独立存在，而是互相依赖互相补充） 设计原则名称 简单定义 开闭原则 对扩展开放，对修改关闭 单一职责原则 一个类只负责一个功能领域中的相应职责 里氏替换原则 所有引用基类的地方必须能透明的使用其子类的对象 依赖倒置原则 依赖于抽象，而不依赖于具体实现 接口隔离原则 类之间的依赖关系应该建立在最小的接口上 聚合（组合）复用原则 尽量使用聚合（组合），而不是通过继承来达到复用的目的 迪米特法则（最少知识原则） 一个软件实体应该尽可能少的与其他实体发生相互作用 设计模式的组织设计模式在粒度和抽象层次上各不相同。由于存在众多的设计模式，为了对其描述，根据不同的准则对其进行分类，一方面便于对各族相关的模式进行引用，另一方面对发现新的模式也有指导作用。按照目的准则（既模式是用来完成什么工作的）分为 创建型：在创建对象的时候隐藏具体的创建逻辑，并且可以灵活的根据需要创建不同的对象。 结构型：通过类和接口间的继承和引用实现创建复杂结构的对象。 行为型：通过类之间不同通信方式实现不同的行为。显然，作为针对静态对象的创建型和结构型，在实践中的复杂度和广泛性与行为型的不可同日而语。因此行为型的设计模式比以上两者要多出许多按照范围准则分为 类模式：处理类和子类之间的关系，这些关系是通过继承建立，是静态的，编译时刻便确定下来了。由于几乎所有模式都涉及继承机制，所以“类模式”仅指集中于处理类间关系的模式 对象模式：处理对象之间的关系，这些关系在运行时刻是可以变化的，更具动态性 ​ 创建型类模式将对象的部分创建工作延迟到子类，而创建型对象模式则将它延迟到另一个对象中。结构型类模式使用继承机制来组合类，而结构型对象模式则描述了对象的组装方式。行为型类模式使用集成描述算法和控制流，而行为型对象模式则描述一组对象怎样协作完成单个对象所无法完成的任务。当然，描述或者说组织设计模式并非一定要按照不同的准则将其分隔分类，还有一种方式是根据模式的“相关模式”来描述他们怎样相互引用，并以此来组织设计模式，如下图所示接下来，结合Java语言详细的针对每一种设计模式做解释引用及参考GoF 设计模式Java Design Patterns强烈推荐.提取码:o632demo code@github" }, { "title": "使用自动操作快速移动文件", "url": "/posts/%E4%BD%BF%E7%94%A8%E8%87%AA%E5%8A%A8%E6%93%8D%E4%BD%9C%E5%BF%AB%E9%80%9F%E7%A7%BB%E5%8A%A8%E6%96%87%E4%BB%B6/", "categories": "work, 利其器", "tags": "mac, automator", "date": "2022-02-08 17:56:49 +0800", "snippet": "mac下面每次要移动文件，都要多打开个访达窗口，然后拉过去，通过自动操作写了个流程，在需要移动的文件上右键调用快速操作中的“移动文件”即可弹窗，选中目的文件夹，可以直接移动文件，对该过程做个记录1、打开自动操作，新建快速操作2、输入改为文件和文件夹，位于改为访达，图像和颜色自定义以方便自己查看3、从资源库中找到设定变量的值操作，并添加到当前工作流程，新建变量path4、从资源库中找到请求访达项目操作，添加到当前流程，并在该操作的选项中选中忽略此操作的输入(未忽略输入时每一项的输出将一直作为下一项的输入向下传递)，开始于可根据需要自行调整，类型选择文件夹（此为目标文件夹）5、添加获取变量的值操作到当前流程，变量为上面新建的path变量6、添加运行shell脚本操作到当前流程，并修改传递输入为“至stdin”(作为自变量的话会将多个按行分隔的文件或文件夹路径作为一个参数传递过来，需自行处理后使用)7、在shell脚本中添加移动文件逻辑如下read target_path#/usr/bin/osascript -e &quot;display notification \\&quot;get target: $target_path\\&quot;&quot;count=1while read linedo if [ -f &quot;$line&quot; ]; then mv &quot;$line&quot; &quot;$target_path&quot; elif [ -d &quot;$line&quot; ]; then mv &quot;$line&quot; &quot;$target_path&quot; else /usr/bin/osascript -e &quot;display notification \\&quot;unknown file: $line\\&quot;&quot; fi #/usr/bin/osascript -e &quot;display notification \\&quot;get line $count: $line\\&quot;&quot; count=$[$count + 1]done操作完成后整个工作流程如图所示参考资料：自动操作官方使用手册mac上使用自动操作编写脚本mac发送通知AppleScript Language Guide(官方文档)AppleScript Tutorial" }, { "title": "科目一", "url": "/posts/%E7%A7%91%E7%9B%AE%E4%B8%80/", "categories": "life, 驾考", "tags": "driving", "date": "2022-01-19 15:27:04 +0800", "snippet": " 本文记录科目一考试时的一些易错易混淆知识点，并不全面，仅供参考车辆行驶相关 右转让左转，左转让直行（交叉路口右方道路车辆先行） 城市道路最高速度：不三不四，有五有七 夜间会车距离150m以外由远光灯变为近光灯 高速公路能见度200米以下，最高车速60km/h，车距100m+（261） 高速公路能见度100米以下，最高车速40km/h，车距50m+ （145） 高速公路能见度50米以下，最高车速20km/h，离开高速公路 （52） 故障停车，放置警告标识：一般道路 [50m,100m] 高速公路 $[150m, +\\infty) $ 驾驶技能准考证明有效期(3年)内，科目二和科目三考试预约次数不得超过5次 驾驶证补领到核发地，换领到居住地，车辆行驶证到登记地 （补核换居车登） 有效期满或户籍迁出需换领驾驶证时，需接受审验 危险驾驶罪为 醉驾、追逐竞驶，情节恶劣、校车或客运超载或超速、违反管理规定运送危险化学品 高速公路行驶，100km/h以下车距为（50m, 100m]，100km/h以上车距为 $[100m, +\\infty) $ 申请C1/C2/C3驾驶证，两眼裸视力或矫正视力需4.9以上，中大型客货车、城市公交车5.0以上 高速公路路面限速标记，白色车速为最低限速，黄色车速为最高限速 上路行驶车辆有以下行为，交警可依法扣留车辆（一牌两证两标） 未悬挂机动车号牌 未放置检验合格、保险标志 未随车携带行驶证、驾驶证 初次申请机动车驾驶证，可申请准驾车型： 城市公交车 大型货车 小型、小型自动挡、低速载货、三轮、残疾人专用小型自动挡载客汽车 普通二轮、普通三轮、轻便摩托车 轮式自行机械车 有轨、无轨电车 扣分相关 未携带行驶证 1分 不按规定会车 1分 不按规定使用灯光 1分（超车：一灯二超三违规） 借道超车 2分 开车打电话 2分 交叉路口不按规定行车或停车 2分 高速、城市快速路未系安全带(一般道路不扣分仅罚款50) 2分 未按规定年检 3分 高速公路禁止驶入 3分 高速公路不按规定车道行驶 3分 违反禁令标志、禁止标线指示 3分 人行横道不按规定减速，停车，避让行人 3分 一般道路不按规定超车、让行，或者逆行 3分 发生事故停车后，不按规定设置灯光和警告标志 3分 违反信号灯 6分 暂扣期间驾驶 6分 隐瞒、欺骗手段补领驾驶证，罚款200-500 6分 占用应急车道、违反信号灯、未避让校车（六一儿童节） 6分 高速公路 超速10%以内 警告 超速10%-20% 3分 超速20%-50% 6分 超速50%以上 12分 饮酒、醉酒 12分 驾驶车型不符 12分 交通肇事逃逸 12分 高速公路倒车、逆行、穿越隔离带 12分处罚相关 交通违法的处罚形式：警告、罚款、暂扣、吊销、拘留 驾驶拼装、报废机动车上路 处 (200, 2000] 罚款，收缴车辆，吊销驾照 强行通行，不听劝阻 处 (200, 2000] 罚款 醉酒驾驶 处拘役，并处罚金 追逐竞驶，情节恶劣 处拘役，并处罚金 事故逃逸不构成犯罪，处 (200, 2000] 罚款，可以并处15日以下拘留 20毫克/100毫升以上 酒驾 80毫克/100毫升以上 醉驾 超速50%以上，处 (200, 2000] 罚款，可以并处吊销机动车驾驶证 补领驾驶证后仍使用原有驾驶证 处 (20, 200] 罚款 逾期未审，处 (200, 500] 罚款 (逾期未审，二百五) 实习期单独上高速公路，处 (20, 200] 罚款 无证驾驶、吊销或暂扣期间驾驶 处 (200, 2000] 罚款，扣6分，可以并处15日以下拘留 非法拦截交通堵塞或较大财产损失 处 (200, 2000] 罚款，可以并处15日以下拘留时长、等待间隔相关 实习期：12个月 道路交通安全违法行为累计记分周期：12个月 机动车驾驶证分为：六年、十年、长期 驾驶技能准考证明有效期：3年 驾驶人信息发生变化，需在30日内申请换证 报废期满2个月前通知机动车所有人办理注销登记 驾驶证有效期满前申请换证：90日 驾驶人无法期满换证、审验、提交身体条件证明时，延期审验不超过3年 提供虚假材料申领驾驶证，1年内不得再次申领（假1吊2撤3醉5逃犯终身） 考试过程贿赂舞弊，取消成绩，1年内不得重新申请驾照（假1吊2撤3醉5逃犯终身） 不正当手段取得驾照，撤销、吊销驾驶许可，3年内不得重新申请（假1吊2撤3醉5逃犯终身） 饮酒驾车，暂扣驾驶证6个月，(1000, 2000] 罚款；再次饮酒驾驶，处 (0, 10日] 拘留, (1000, 2000] 罚款，吊销机动车驾驶证 事后报警，交管部门3天内决定是否受理 一个记分周期2次扣完12分或累计24分，科一考完10日内考科三。一次的在15日内到交管部门学习7天科一 科一合格后车管所应在1日内核发学习驾驶证明 驾照考试合格，5日内核发驾驶证 驾驶人违反交通运输管理法规发生重大事故致人重伤、死亡，可处 亡而未逃 （0，3） 先亡再逃 （3，7） 先逃再亡 $[7, +\\infty) $ 指路、指示、禁止等标识相关 禁止标识 红白相间 警告标识 黄色黑边 蓝色停车位 免费 白色停车位 收费 黄色停车位 专用双向交通(只有箭头),分离式道路(箭头有连接),潮汐车道(有虚线)特殊天气建议速度圆形指示仅允许直行，方形无虚线为直行路，方形有虚线为直行车道科目四补充高速公路速度上限：小型载客汽车≤120，其他≤100，摩托车≤80弯道、铁路道口、窄路、窄桥、能见度低于50、冰雪、泥泞道路、牵引车等各种紧急或事故易发场景，时速≤30客车按照乘员分类： 大型客车：20人+ 中型：（10-20） 小型：（0-10） 微型：（0-9），且排量≤1L 让行标志前：减速慢行，缓慢通过路口停止标志前：需停车观察后通过路口交警手势：注意分辨减速和待转（记忆tips，左手单摆左待转，右手单摆要减速）前轮抱死不能控制方向，后轮抱死会侧翻前轮打滑往相反方向，后轮打滑往相同方向可以防止侧翻（第一原则是握稳方向盘，缓慢减速，以上规则属于高速运动紧急情况下适当修正方向盘的方式）转弯右让左（右转比左转少一个红绿灯需要注意），变道左让右（驾驶位在左侧，左让右可以保证非变动司机随时可以响应紧急情况）261 145 520（高速能见度低于200m，限速60km/h，车距100m+；能见度低于100，限速40，车距50+，低于50，限速20，尽快离开高速公路）公交站、加油站附近临时停车不得距离30m以内，其他各种地点临时停车不得在50m以内" } ]
